{"meta":{"title":"RedWolfChao Blog","subtitle":"沉默是金","description":"学海无涯,回头是岸,阿弥陀佛","author":"RedWolfChao","url":"http://joryhe.coding.me"},"pages":[{"title":"RedWolfChao Blog","date":"2017-04-24T01:41:06.000Z","updated":"2017-04-26T03:00:35.327Z","comments":true,"path":"tags/index.html","permalink":"http://joryhe.coding.me/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-04-24T01:42:11.000Z","updated":"2017-04-24T01:43:05.442Z","comments":true,"path":"categories/index.html","permalink":"http://joryhe.coding.me/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"安卓移动逆向(四)-Smail_HelloWorld","slug":"安卓移动逆向(四)-Smail_HelloWorld","date":"2017-05-08T10:18:18.000Z","updated":"2017-05-10T09:37:32.439Z","comments":true,"path":"post/安卓移动逆向(四)-Smail_HelloWorld.html","link":"","permalink":"http://joryhe.coding.me/post/安卓移动逆向(四)-Smail_HelloWorld.html","excerpt":"","text":"###着手编写一个Smail类型的HelloWord### 开始编写 不要直接复制,要一个一个字符敲,否则没有意义!!不要直接复制,要一个一个字符敲,否则没有意义!!!!不要直接复制,要一个一个字符敲,否则没有意义!!!!!! .class public LHelloWorld; #定义类名.super Ljava/lang/Object; #定义父类.method public static main&#123;[Ljava/lang/String;&#125;V #声明main()&lt;主函数&gt; .registers 4 #程序中使用v0,v1,v2寄存器与一个参数寄存器 .prologue #代码起始指令 return-void #没有返回值void .end method 这是一段HelloWorld的架构代码,定义了一个可编译运行的DEX文件的最小组成部分,下面我们将在.prologue(代码起始指令)下编写具体代码: #空指令nopnopnop#数据定义指令const/16 v0, 0x8 #v0=0x8const/4 v1, 0x5 #v1=0v5const/4 v2, 0x3 #v2=0x3#数据操作指令move v1, v2 #v1=v2#数组操作指令new-array v0,v0,[I # v0 = new int[v0(8)];array-length v1, v0 # v1 = v0(8);#实例操作指令new-instance v1, Ljava/lang/StringBuilder; #v1 = new StringBuilder();#方法调用指令invoke-direct&#123;v1&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V #(不确定是不是这个意思) void init(v1)#跳转指令if-nez v0, :cond_0 #如果v0!=0;则跳转到cond_0goto : goto_0 #否则就进入goto_0:cond_0 #cond_0开始#数据转换指令int-to-float v2,v2 #v2 = (float)v2#数据运算指令add-float v2,v2,v2 #v2 = v2+v2#比较指令cmpl-float v0,v2,v2 #if(v2==v2) v0 = 0#字段操作指令sget-object v0,Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; # v0 = out();const-string v1,\"HelloWorld\" #构造字符串 v1 = \"HellpWorld\"#方法调用指令invoke-virtual&#123;v0,v1&#125;,Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V #out.println(v1)#返回指令:goto_0 #goto_0 开始 完成代码如下, .class public LHelloWorld; #定义类名.super Ljava/lang/Object; #定义父类.method public static main([Ljava/lang/String;)V #声明main()&lt;主函数&gt; .registers 4 #程序中使用v0,v1,v2寄存器与一个参数寄存器 .prologue #代码起始指令 #空指令 nop nop nop #数据定义指令 const/16 v0, 0x8 #v0=0x8 const/4 v1, 0x5 #v1=0v5 const/4 v2, 0x3 #v2=0x3 #数据操作指令 move v1, v2 #v1=v2 #数组操作指令 new-array v0,v0,[I # v0 = new int[v0(8)]; array-length v1, v0 # v1 = v0(8); #实例操作指令 new-instance v1, Ljava/lang/StringBuilder; #v1 = new StringBuilder(); #方法调用指令 invoke-direct&#123;v1&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V #(不确定是不是这个意思) void init(v1) #跳转指令 if-nez v0, :cond_0 #如果v0!=0;则跳转到cond_0 goto : goto_0 #否则就进入goto_0 :cond_0 #cond_0开始 #数据转换指令 int-to-float v2,v2 #v2 = (float)v2 #数据运算指令 add-float v2,v2,v2 #v2 = v2+v2 #比较指令 cmpl-float v0,v2,v2 #if(v2==v2) v0 = 0 #字段操作指令 sget-object v0,Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; # v0 = out(); const-string v1,\"HelloWorld\" #构造字符串 v1 = \"HellpWorld\" #方法调用指令 invoke-virtual&#123;v0,v1&#125;,Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V #out.println(v1) #返回指令 :goto_0 #goto_0 开始 return-void #没有返回值void .end method 然后我们可以通过命令java -jar E:\\Reverse\\smali_baksmali\\smali.jar -o classes.dex HelloWorld.smali来将Smali文件打包成dex文件(这里的”E:\\Reverse\\smali_baksmali\\smali.jar”要是配置了环境变量就不用这样带路径了,下面的也是一样) 如果没有报错,就会在当前目录下生成classes.dex(报错了就根据提示调错就好) 然后我们将classes.dex压缩为HelloWorld.zip 测试的时候要保证电脑连着一个手机(已Root)或者有一个模拟器 执行adb push HelloWorld.zip /data/local/ 有的童鞋可能会报下面这个错误 adb server version (31) doesn't match this client (39)* daemon started successfully * error: no devices/emulators found 原因是新版adb错误,我们下载旧版的adb用旧版的adb运行即可 最后,执行adb shell dalvikvm -cp /data/local/HelloWorld.zip HelloWorld就可以了,附图 这里写图片描述 这个是Smali.jar 这个是旧版的adb","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://joryhe.coding.me/tags/Android逆向/"}]},{"title":"安卓移动逆向(三)-Android Dalvik虚拟机","slug":"安卓移动逆向(三)-Android Dalvik虚拟机","date":"2017-05-03T05:13:13.000Z","updated":"2017-05-10T09:37:12.355Z","comments":true,"path":"post/安卓移动逆向(三)-Android Dalvik虚拟机.html","link":"","permalink":"http://joryhe.coding.me/post/安卓移动逆向(三)-Android Dalvik虚拟机.html","excerpt":"","text":"大家都知道Java程序是运行在Java虚拟机上,Android程序呢?虽然Android平台使用Java语言来开发应用程序,但是Android程序却不是运行在标准的Java虚拟机上的. Google为Android平台专门设计了一套虚拟机来运行Android程序–Dalvik Virtual Machine,也就是Dalvik虚拟机了 本篇作用: 扫盲Dalvik虚拟机 了解Smail的语法,能读懂Smail文件 ###Dalvik概述### ####Dalvik的特点(相对于JVM)#### 体积小,占用内存小; 专有的DEX可执行文件格式,体积更小,执行速度更快; 常量池采用32位索引值,寻址类方法名,字段名,常亮更快; 基于寄存器架构,并拥有一套完成的指令系统 提供了对象生命周期管理,堆栈管理,线程管理,安全和异常管理以及垃圾回收等重要功能; 所有的Android程序都运行在Android系统进程里,每个进程对应着一个Dalvik虚拟机实例; ####Dalvik虚拟机与Java虚拟机的区别#### Java虚拟机运行的Java字节码,Dalvik虚拟机运行的是Dalvik字节码 Dalvik可执行文件的体积更小稍作解析:SDK中有一个叫做dx的工具负责将Java字节码转换为Dalvik字节码.dx工具对Java类文件重新排列,消除在类文件中出现的所有冗余信息,避免虚拟机在初始化时出现重复的文件加载与解析过程. 举个栗子:在Java中有大量的字符串常量在多个类文件中被重复使用,这些荣誉信息会直接增加文件的体积,同事也会严重影响虚拟机解析文件的效率.dx工具针对这个问题做了专门的处理,它将所有Java类文件中的常量池进行分解,消除其中的冗余信息,重新组合成一个常量池,所有的类文件共享同一个常量池.dx工具转换过程如图所示,由于dx工具对常量池的压缩,是的相同的字符串,常量在DEX文件中只出现一次,从而减小了文件的体积. dx工具转换过程 Java虚拟机与Dalvik虚拟机架构不同 简单说一下:Java虚拟机基于栈架构,Dalvik基于寄存器架构; ###Dalvik指令格式### 一般Dalvik汇编代码由一系列的Dalvik指令组成,指令语法由指令的位描述与指令格式标识来决定.位描述约定如下 每16位的字采用空格分割开来; 每个字母表示四位,每个字母按顺序从高字节开始,排列到低字节.每四位之间可能用竖线”|”来表示不同的内容; 顺序采用A-Z的翻个大写字母作为一个4位的操作码,op表示一个8位的操作码; “?”来表示这个字段的所有位为0值; 栗子 “A|B|op BBBB F|E|D|C” 指令中间有两个空格,每个分开的部分是16位,共有3个16位组成这条指令; 第一个16位是”A|B|op” 高8位由A和B组成,低字节由操作码op组成; 第二个16位由BBBB组成,他表示一个16位的偏移值; 第三个16位分别由F,E,D,C共四个字节组成,在这里他们表示寄存器的参数. 单独使用位标识还无法确定一条指令的意思,必须通过指令格式标识来指定指令的格式编码,约定如下 指令格式标识大多由三个字符组成,前两个是数字,最后一个是字母; 第一个数字式标识指令由多少个16位的字组成; 第二个数字标识指令最多使用寄存器的个数,特殊标记”r”标识使用一定范围内的寄存器; 第三个字母为类型码,标识指令用到的额外数据的类型,见下图: 还有一种特殊的情况 是末尾可能还会多出另一个字母,如果是”s”表示指令采用静态链接,如果是”i”表示指令应该被内联处理. 栗子 “22x” 有三条信息可以读出 指令由2个16位字组成 指令使用2个寄存器 没有使用到额外的数据 另外,Dalvik指令对语法做了一些说明,约定如下 每条指令从操作码开始,后面紧跟参数,参数个数不定,每个参数之间采用逗号分开; 每条指令的参数从指令的第一部分开始,op位于低8位,高8位可以是一个8位的参数也可以是两个4位的参数,还可以为空.如果指令超过16位,则后面的部分依次作为参数; 如果参数使用”vX”的方式标识,表明它是一个寄存器,如v0,v1等; 如果参数采用”#+X”的方式,表明它是一个常量数字; 如果参数采用”+X”的方式,表明它是一个相对指令的地址偏移; 如果参数采用”kind@X”的方式,表明它是一个常量池索引值.其中kind表示常量池类型,例如string@BBBB,表示的就是字符串常量池索引BBBB; 栗子“op vAA string@BBBB”高8位为空,用到1个寄存器参数vAA,还用到一个字符串常量池索引BBBB; ###Dalvik寄存器### 扫盲结束了,开始重点了 ####Dalvik字节码的类型,方法,与字段表示方法#### 类型Dalvik字节码只有两种类型,基本与引用,话不多说,看图; 类型 每个Dalvik寄存器都是32位大小,对于小鱼或者等于32位长度的类型来说,一个寄存器就可以存放该类型的值,而像J(long),D(double)等64位的类型,它们的值是使用相邻量个寄存器来存储的,v0和v1或者vN与vN+1等;L就好理解了,表示任何一个Java类,在Dalvik汇编代码中,它们以” Lpackage/name/ObjectName; “表示,注意最后一个分号,比如” Ljava/lang/String;”相当于String;[类型就是所有的数组,[后面紧跟基本类型的描述符,如[I表示一个整型一维数组,-&gt;int[],[[I表示int[][]&lt;—&gt; [Ljava/lang/String; 表示对象数组 String []; 方法Dalvik使用方法名,类型参数与返回值来描述一个方法;格式如下:Lpackage/name/ObjectName;-&gt;MethodName(III)Z说明:Lpackage/name/ObjectName;是一个类型;MethodName方法名(III)参数,三个int参数Z返回值void栗子method(I[[IILjava/lang/String;[Ljava/lang/String;)Ljava/lang/String;咳咳,按照上面的知识,将其转换为Java形式的代码为:String method(int ,int[][],String,String[]) 字段字段和方法很相似,就是没有参数和返回值,取而代之的是字段的类型,格式如下Lpackage/name/ObjectName;-&gt;FieldName:TYPE说明:Lpackage/name/ObjectName;是一个类型;FieldName字段名TYPE字段类型FieldName与TYPE用冒号隔开栗子name:Ljava/lang/String;转换:String name;Dalvik代码中的字段代码以.field指令开头,根据字段类型不同,在字段指令的开始,可能会用到井号”#”加以注释; ###Dalvik指令集### ####指令特点#### Dalvik指令在调用格式上模仿了C语言的调用约定.Dalvik指令语法与助词符有如下特点: 参数采用从目标(destination)到源(source)的方式; 根据字节码的布局与选项的不同,一些字节码添加了字节码后缀消除歧义,这些后缀通过在字节码主名称后添加斜杠”/“来分隔开; 在指令集的描述中,宽度值中的每个字母表示宽度为4位; 根据字节码的大小与类型的不同,一些字节码添加了名称后缀以消除歧义: 32位常规类型的字节码,未添加任何后缀; 64位常规类型的字节码以-wide后缀; 特殊类型的字节码根据具体类型添加后缀,他们可以是-boolean,-byte,-char,-short,-int,-long,-float,-double,-object,-string,-class,-void之一; 栗子“move-wide/from16 vAA,vBBBB” move为基础字节码.标识这是基本操作;wide为名称后缀.标识指令操作的数据宽度(64位);from16位字节码后缀.标识源为一个16位的寄存器引用变量;vAA为目的寄存器,它始终在源的前面 取值范围为v0-v2^8-1(255);vBBBB为源寄存器,取值范围为v0-v2^16-1(65535) 空操作指令 空操作指令的助记符为nop,他的值是00,通常nop指令被用过对齐代码用途,没啥大用; 数据操作指令 数据操作指令为move.move指令的原型为move destination,source或者move destination,move指令根据字节码的大小与类型不同,后面会跟上不同的后缀.栗子(表示太多直接上图,都差不多) 数据操作指令 返回指令 返回指令指的是函数结尾时运行的最后一条指令.他的基础字节码位return,共有以下四条返回指令栗子 “return-void” 返回一个void “return vAA” 返回一个32位非对象类型的值,返回值寄存器位8位的寄存器vAA; “return-wide vAA” 返回一个64位非对象类型的值,返回值寄存器位8位的寄存器vAA; “return-object vAA” 返回一个对象类型的值,返回值寄存器位8位的寄存器vAA; 数据定义指令 数据定义指令用来定义程序中用到的变量,字符串,类等数据,他的基础字节码为const栗子(表示太多直接上图-_-) 这里写图片描述 这里写图片描述 锁指令 锁指令多用在多线程程序中对同一对象的操作,Dalvik指令集中有两条锁指令. “monitor-enter vAA” 为指定的对象获取锁 “monitor-exit vAA”为指定的对象释放锁 实例操作指令 与实例相关的操作包括实例的类型传换,检查及新建等; “check-case vAA,type@BBBB” 将vAA中的对象引用强转为BBBB类型; (BBBB)vAA; “instance-of vA,vB,type@CCCC” 判断vB中的对象引用是否能转成CCCC类型,能vA=1,不能vA=0; if(vB.instanceof(type@CCCC))&#123; vA =1;&#125;else&#123; vA = 0;&#125; “new-instance vAA,type@BBBB” 新建一个BBBB的对象vAA,BBBB不能为数组 BBBB vAA = new BBBB(); “check-cast/jumbo vAAAA,type@BBBBBBBB” 与”check-case vAA,type@BBBB”作用相同,只是取值范围更大(Android 4.0新增) “instance-of/jumbo vAAAA,vBBBB,type@CCCCCCCC”与”instance-of vAA,vBB,type@CCCC”作用相同,只是取值范围更大(Android 4.0新增) “new-instance/jumbo vAAAA,type@BBBBBBBB”与”new-instance vAA,type@BBBB”作用相同,只是取值范围更大(Android 4.0新增) 数组操作指令 数组操作包括获取数组长度(指的是数组的条目个数),新建数组,数组赋值,数组元素取值与赋值等操作; “array-length vA,vB” vA = vB.length; // 将vB的长度赋值给vA “new-array vA,vB,type@CCCC” vA = CCCC[vB]; // 构建一个vB大的CCCC类型的数组赋值给vA 其余的附图 这里写图片描述 异常指令 Dalvik 指令集中有一条指令用于抛出异常 “throw vAA” 抛出vAA寄存器中指定类型的异常 跳转指令 Dalvik指令集中有三种跳转指令:无条件跳转(goto),分支跳转(switch),条件跳转(if) “goto +AA” 无条件跳转到指定偏移处,偏移量AA不能为0; “goto/16+AAAA” 无条件跳转到指定偏移处,偏移量AAAA不能为0; “goto/32+AAAAAAAA” 无条件跳转到指定偏移处; “packed-switch vAA,+BBBBBBBB” 分支跳转指令. vAA寄存器为switch分支中需要判断的值即(switch(vAA)),BBBBBBBB指向一个packed-switch-payload格式的偏移表,表中的值是规律递增的.(先这么记住就好,感兴趣可以找百度..) “sparse-switch vAA,+BBBBBBBB”分支跳转指令,vAA寄存器为switch分支中需要判断的值即(switch(vAA)),BBBBBBBB指向一个sparse-switch-payload格式的偏移表,表中的值是无规律的偏移量. “if-test vA,vB,+CCCC” 条件跳转指令,比较vA与vB的值,如果比较结果满足就跳转到CCCC指定的偏移处,偏移量CCCC不能为0,if-test类型的指令有以下几条: “if-eq vA, vB, :cond_xx” 如果vA等于vB则跳转到:cond_xx “if-ne vA, vB, :cond_xx” 如果vA不等于vB则跳转到:cond_xx “if-lt vA, vB, :cond_xx” 如果vA小于vB则跳转到:cond_xx “if-ge vA, vB, :cond_xx” 如果vA大于等于vB则跳转到:cond_xx “if-gt vA, vB, :cond_xx” 如果vA大于vB则跳转到:cond_xx “if-le vA, vB, :cond_xx” 如果vA小于等于vB则跳转到:cond_xx “if-testz vAA,+BBBB”条件跳转指令,那vAA与0作比较,满足结果或者不满足结果就跳转到BBBB的指定偏移处BBBB不能为0, if-testz类型的指令有以下几条: “if-eqz vA, :cond_xx” 如果vA等于0则跳转到:cond_xx “if-nez vA, :cond_xx” 如果vA不等于0则跳转到:cond_xx “if-ltz vA, :cond_xx” 如果vA小于0则跳转到:cond_xx “if-gez vA, :cond_xx” 如果vA大于等于0则跳转到:cond_xx “if-gtz vA, :cond_xx” 如果vA大于0则跳转到:cond_xx “if-lez vA, :cond_xx” 如果vA小于等于0则跳转到:cond_xx 比较指令 比较指令用于对两个寄存器的值(浮点型或者长整型)进行比较格式为:“cmpkind vAA,vBB,vCC” Dalvik指令集中共有5条比较指令: “cmpl-float” 比较两个float值; if(vBB == vCC)&#123; vAA =0;&#125;else if(vBB&gt;vCC)&#123; vAA = -1;&#125;else if(vBB&lt;vCC&gt;)&#123; vAA = 1;&#125; “cmpg-float” 比较两个float的值 if(vBB == vCC)&#123; vAA =0;&#125;else if(vBB&lt;vCC)&#123; vAA = -1;&#125;else if(vBB&gt;vCC&gt;)&#123; vAA = 1;&#125; 当cmpg或者cmp时,B &gt; C时A = 1,反之-1;当cmpl时,B &gt; C时A = -1反之1; “cmpg-double” 比较两个double的值 “cmpl-double” 比较两个double的值 “cmp-long” 比较两个long的值 字段操作指令 字段操作指令用来对对象实例的字段进行读写操作.字段的类型可以是Java中有效的数据类型,对普通字段与静态字段操作有两种指令集,分别是”iinstanceop vA,vB,field@CCCC”与”sstaticop vAA,field@BBBB”.在Android 4.0系统中,有”iinstanceop /jumbovAAAA,vBBBB,field@CCCCCCCC”与”sstaticop/jumbo vAAAA,field@BBBBBBBB”.和上面的两种作用相同,只是加了jmpbo后缀,寄存器与指令索引取值范围更大(后面的只会说有/jumbo指令后缀的指令集,作用就不指明了)普通字段指令的指令前缀为i,如.对普通字段读操作使用iget指令,写操作使用iput指令;静态字段的指令前缀为s,如.对静态字段的读操作为sget,写操作为sput;根据访问的字段类型不同,字段操作指令后面会紧跟字段类型的后缀,如iget-byte指令表示读取实例字段的值类型为byte; 方法调用指令方法调用指令负责调用类实例的方法,它的基础指令为invoke,方法调用指令有”invoke-kind{vC,vD,vE,vF,vG},meth@BBBB”与”invoke-kind/range{vCCCC…VNNNN},meth@BBBB”两类,这两类指令作用没啥不同,后者在设置参数寄存器时使用了range来指定寄存器的范围,根据方法类型的不同,共有如下5条方法调用指令: “invoke-virtual” 调用实例的虚方法 “invoke-super” 调用实例的父类方法 “invoke-direct” 调用实例的直接方法 “invoke-static” 调用实例的静态方法 “invoke-interface” 调用实例的接口方法Android 4.0有jumbo的指令集; 方法调用指令的返回值必须使用move-result*指令来获取:invoke-static{},Landroid/os/Parcel;-&gt;obtain()Landroid/os/Parcel;move-result-object v0; 数据转换指令数据转换指令用于将一种类型的数值转换为另一种类型,他的格式为”unop vA,vB” 把vB中的数据做一定运算(转换)放在vA中:(比较简单,直接上图) 这里写图片描述 数据运算指令 数据运算指令包括算数运算指令与逻辑运算指令: 算数运算指令:加,减,乘,除,模,移位等 逻辑运算指令:间与,或,非,抑或等;上个图吧 这里写图片描述 其中基础字节码后面的-type可以是-int,-long,-float,-double,后面3类指令也差不多,就不列了,触类旁通; == == == == == == == == == == == == == == == == == == == == == ==","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://joryhe.coding.me/tags/Android逆向/"}]},{"title":"安卓移动逆向(二)","slug":"安卓移动逆向(二)","date":"2017-05-02T04:12:12.000Z","updated":"2017-05-10T09:36:57.451Z","comments":true,"path":"post/安卓移动逆向(二).html","link":"","permalink":"http://joryhe.coding.me/post/安卓移动逆向(二).html","excerpt":"","text":"###小实践–破解一个小程序### 如何破解 破解Android程序通常的方法是将apk文件利用ApkTool反编译,生成Smali格式的反汇编代码.然后阅读Smali文件的代码来理解程序的运行机制,找到程序的突破口进行修改,最后使用ApkTool重新编译生成Apk文件并签名,最后运行测试,如此循环,直到程序被成功破解. 需要工具 编译工具 : ApkTool 签名工具: SignApk : 链接：http://pan.baidu.com/s/1miwl6lU 密码：ze44 下载完之后 解压目录到path环境变量 你懂得 准备 我们先建立一个自己的App,长得像这样(PS:不愿意自己建有源码下载) 待破解代码 功能就是根据输入的用户名生成注册码,判断输入的注册码和系统算法生成的注册码是否一致,一致则注册成功,软件可用,否则则不可用; 软件 软件核心代码 findViewById(R.id.act_main_btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String userName = etUser.getText().toString().trim(); String sn = etSN.getText().toString().trim(); if (checkSN(userName, sn)) &#123; Toast.makeText(MainActivity.this, R.string.string_register, Toast.LENGTH_SHORT).show(); tvTitle.setText(R.string.string_success_register); &#125; else &#123; Toast.makeText(MainActivity.this, R.string.string_unregister, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); 开始破解 首先我们需要用apktool d appname.apk 进行反编译 如图 反编译 然后生成了一个appName的文件夹 里面就是 那些smali等文件了 之后我们的目的 是找到突破口,什么是突破口? 点击Button之后的提示文字就是突破口 我们进入values中的string.xml找找看 .. 开发Android程序时,String.xml文件中的所有字符串资源都在”gen//R.java”文件的String类中被标识,每个字符串都有唯一的int类型索引值,使用ApkTool反编译Apk文件后,所有的索引值保存在string.xml文件同目录下的public.xml中 搜索string_unregister在public.xml中 这里写图片描述 我们发现string_unregister所对应的id为 0x7f060027 书上说需要全局搜索smali文件夹中包含0x7f060027文件的位置,我们知道是在MainActivity中声明的,直接进入即可(PS:惭愧,我不知道如何全局搜索文件内的内容) 我们进入MainActivity$1.smali搜索0x7f060027 如图 这里写图片描述 解析如下 这里写图片描述 按图修改之后,我们进入app文件夹,再次编译打包会在dist中生成一个app,我们现在签名(不签名是无法运行测试的) 如图 这里写图片描述 然后我们进行签名,用我们下载的signapk工具,生成-&gt;已签名的App 如图 这里写图片描述 生成之后 我们可以通过adb install signed.apk 安装到手机测试 也可以复制到手机上直接安装,哦,可能会报错 这里写图片描述 把手机上的相同App卸载了即可 安装之后,就这样了 这里写图片描述 参考书籍: Android软件安全与逆向分析","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://joryhe.coding.me/tags/Android逆向/"}]},{"title":"安卓移动逆向(扫盲)","slug":"安卓移动逆向(扫盲)","date":"2017-05-01T03:11:11.000Z","updated":"2017-05-10T09:37:22.612Z","comments":true,"path":"post/安卓移动逆向(扫盲).html","link":"","permalink":"http://joryhe.coding.me/post/安卓移动逆向(扫盲).html","excerpt":"","text":"###Android 逆向 ### 没啥好说的,先扫一下盲 ###APK 组成 ### asset文件夹： 资源目录1：asset和res都是资源目录但有所区别，见下面说明 lib文件夹： so库存放位置，一般由NDK编译得到，常见于使用游戏引擎或JNI native调用的工程中 res文件夹 ：资源目录2：asset和res都是资源目录但有所区别，见下面说明 classes.dex ： Java代码编译得到的Dalvik VM能直接执行的文件，下面有介绍 res目录下的资源文件在编译时会自动生成索引文件（R.java），在Java代码中用R.xxx.yyy来引用；而asset目录下的资源文件不需要生成索引，在Java代码中需要用AssetManager来访问； 一般来说，除了音频和视频资源（需要放在raw或asset下），使用Java开发的Android工程使用到的资源文件都会放在res下；使用C++游戏引擎（或使用Lua Unity3D等）的资源文件均需要放在asset下。 ###Dalvik 字节码 ### Dalvik字节码是什么？ Dalvik字节码是学习破解的基础，对它我们需要了解一下 Dalvik是google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用java来开发的，但是Dalvik和标准的java虚拟机JVM还是两回事。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex（dalvik executable），而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。 通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如Apktool或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译。 ###Smali–破解的重中之重### 什么是Smali？ Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种。dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了.dex格式所有功能（注解，调试信息，线路信息等） 当我们对APK文件进行反编译后，便会生成此类的文件，小编在此对smali文件进行简要的介绍。其中在Davlik字节码中，寄存器都是32位的，能够支持任何类型，64位类型（Long/Double）用2个寄存器表示；Dalvik字节码有两种类型：原始类型；引用类型（包括对象和数组） 原始类型 B—byteC—charD—doubleF—floatI—intJ—longS—shortV—voidZ—boolean[XXX—arrayLxxx/yyy—object 这里解析下最后两项，数组的表示方式是：在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F；对象的表示则以L作为开头，格式是LpackageName/objectName;（注意必须有个分号跟在最后），例如String对象在smali中为：Ljava/lang/String;，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。 或许有人问，既然类是用LpackageName/objectName;来表示，那类里面的内部类又如何在smali中引用呢?答案是：LpackageName/objectName$$subObjectName;。也就是在内部类前加“$”符号，关于“$”符号更多的规则将在后面谈到。 方法的定义一般为： Func-Name (Para-Type1Para-Type2Para-Type3…)Return-Type 注意参数与参数之间没有任何分隔符，同样举几个例子就容易明白了： 1. hello ()V 没错，这就是void hello()。 2. hello (III)Z 这个则是boolean hello(int, int, int)。 3. hello (Z[I[ILjava/lang/String;J)Ljava/lang/String; 看出来这是String hello (boolean, int[], int[], String, long) 了吗？ Smali基本语法 .field private isFlag:z 定义变量.method 方法.parameter 方法参数.prologue 方法开始.line 123 此方法位于第123行invoke-super 调用父函数const/high16 v0, 0x7fo3 把0x7fo3赋值给v0invoke-direct 调用函数return-void 函数返回void.end method 函数结束new-instance 创建实例iput-object 对象赋值iget-object 调用对象invoke-static 调用静态函数 条件跳转分支： “if-eq vA, vB, :cond_xx” 如果vA等于vB则跳转到:cond_xx“if-ne vA, vB, :cond_xx” 如果vA不等于vB则跳转到:cond_xx“if-lt vA, vB, :cond_xx” 如果vA小于vB则跳转到:cond_xx“if-ge vA, vB, :cond_xx” 如果vA大于等于vB则跳转到:cond_xx“if-gt vA, vB, :cond_xx” 如果vA大于vB则跳转到:cond_xx“if-le vA, vB, :cond_xx” 如果vA小于等于vB则跳转到:cond_xx“if-eqz vA, :cond_xx” 如果vA等于0则跳转到:cond_xx“if-nez vA, :cond_xx” 如果vA不等于0则跳转到:cond_xx“if-ltz vA, :cond_xx” 如果vA小于0则跳转到:cond_xx“if-gez vA, :cond_xx” 如果vA大于等于0则跳转到:cond_xx“if-gtz vA, :cond_xx” 如果vA大于0则跳转到:cond_xx“if-lez vA, :cond_xx” 如果vA小于等于0则跳转到:cond_xx","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://joryhe.coding.me/tags/Android逆向/"}]},{"title":"Lambda表达式--Java 8 新特性","slug":"Lambda表达式","date":"2017-04-28T02:00:00.000Z","updated":"2017-04-28T02:58:56.766Z","comments":true,"path":"post/Lambda表达式.html","link":"","permalink":"http://joryhe.coding.me/post/Lambda表达式.html","excerpt":"","text":"#正文# Lambda表达式是Java 8中提供的新特性-也就是说,要用这个电脑上的JDK环境要是jdk1.8 Lambda表达式本质上是一种匿名方法(匿名的不能再匿名了) 使用它需要在app/gradle中添加如下配置 android &#123; ... defaultConfig &#123; ... // Lambda表达式声明 jackOptions.enabled = true &#125; compileOptions&#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; ...&#125; 简单描述一下适用于什么情况 某个接口只有一个待实现的方法,就可以用了..看栗子吧 先来个容易理解的 线程1 Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;); 线程2 Thread thread1 = new Thread(() -&gt; &#123; &#125;); 体会一下,精不精彩,刺不刺激! …Runnable中只有一个run方法需要实现,所以… 罢了,多看几个例子就懂了 线程3 Runnable runnable = new Runnable() &#123; @Override public void run() &#123; &#125; &#125;; 线程4 Runnable runnable1 = () -&gt; &#123; &#125;; 无奈 结合一下线程1234咱们可以总结出用法 ()代替了(接口名)以及方法名,因为本身就一个 -&gt;{}就是方法体 如果有参数咋办? 栗子(有参数setOnClickListener) 未使用Lambdabtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); 使用了Lambda btn.setOnClickListener((View view) -&gt; &#123; &#125;); 或者 btn.setOnClickListener((view) -&gt; &#123; &#125;); 参数写在()内,参数类型可以省略,Java会自动识别类型(注:当要实现的方法只有一个参数的时候可以写成下面这个样子,因为只有一个参数) btn.setOnClickListener(v -&gt; &#123; &#125;); 着实不能再省了 哦 对了 要是有返回值的话,就直接在{}中return即可 HaveReturn haveReturn = str -&gt; &#123; return false; &#125;;interface HaveReturn &#123; boolean haveReturn(String string);&#125; 无奈 就可以这么用了,太精简了","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://joryhe.coding.me/tags/Java/"}]},{"title":"Material_Design_提供组件","slug":"Material-Design-提供组件","date":"2017-04-26T02:44:41.000Z","updated":"2017-04-26T02:45:26.834Z","comments":true,"path":"post/Material-Design-提供组件.html","link":"","permalink":"http://joryhe.coding.me/post/Material-Design-提供组件.html","excerpt":"","text":"反编译看的实在有点头疼,于是就仔细研究了一下前一段时间的一篇文章Material Design规范,发现这个东西2014年就出来了,为什么我今年才发现呢..无奈.于是乎,读书查资料,撸出一个Demo来; Demo主要知识点&lt;解释纯属个人见解&gt; Toolbar- -&gt;Material Design中推荐用来替代ActionBar的组件 DrawerLayout- -&gt;侧滑菜单的父组件 NavigationView- -&gt;侧滑菜单推荐和DrawerLayout一起组合的使用的菜单组件 FloatingActionButton- -&gt;悬浮按钮 CoordinatorLayout- -&gt;加强版的FrameLayout,拥有部分新特性 Snackbar- -&gt;可交互的Toast(不是替代品) CardView- -&gt;卡片式布局 AppBarLayout-&gt;Toolbar的父组件,封装部分事件 SwipeRefreshLayout- -&gt;下拉刷新组件 CollapsingToolbarLayout- -&gt;只能作为AppBarLayout的直接子布局,用于实现更多效果 RecyclerView- -&gt;ListView的代替品 // 话不多说 1.ToolBar- Toolbar强大之处在于,他不仅继承了ActionBar的所有功能,而且灵活性很高,可以配合其他控件完成一些Material Design的效果 下面我们就来学习一下(首先你需要有一个项目): 修改styles文件中的style部分内容.目的是让ActionBar隐藏,可由多种实现方式,这里提供一种. &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; xml文件中 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;/LinearLayout&gt; 高度为?attr/actionBarSize,也可以自己指定,不过MD规范推荐用这个,同样background也是这个道理 运行 这里写图片描述 ..好难看 替换ActionBarActivity中加入代码 protected void onCreate(Bundle savedInstanceState) &#123; ... Toolbar toolBar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolBar); ... &#125; 运行 这里写图片描述 出现我们的Title了,这个是怎么来的,是我们在Manifest中为application设置的label属性的值.和ActionBar是一样的,现在我们的ToolBar才相当于我们的ActionBar,我们也可以修改这个标题,只需要在Manifest中为当前activity添加一个label属性即可 ToolBar还有好多用法,自己太单调,结合后面的组件一起来 DrawerLayout-好多应用都有这种效果,比如QQ,XX,XXX好多软件用MD中推荐了一种做法 需要修改xml根布局为DrawerLayout并加入一个FrameLayout和一个TextView如下: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:id=\"@+id/drawer_layout\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_gravity=\"\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;/FrameLayout&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:text=\"然而我就是侧拉菜单\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 运行 这里写图片描述 android:layout_gravity=”start”用来设置滑动菜单在左边还是右边 然而还是有点儿问题,因为用户可能根本不知道有这个菜单,因为只有从屏幕左侧向右滑动才可以,所以我们要如此这般 Activity中 @Override protected void onCreate(Bundle savedInstanceState) &#123; ... setSupportActionBar(toolBar); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; // 使ActionBar左侧的按钮默认可见 是一个← actionBar.setDisplayHomeAsUpEnabled(true); // 修改图标 actionBar.setHomeAsUpIndicator(R.drawable.ic_menu_home); &#125; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); break; &#125; return true; &#125; // 然而功能是实现了,但是还是很丑,不过可以的,前面已经说了,有个和DrawerLayout组合用的组件,组合起来用就不丑啦. NavigationView- 使用方法很简单,将原本TextView的位置用NavigationView替换了就是了-&gt;需要加依赖&lt;- compile ‘com.android.support:design:25.3.1’ &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"@color/colorPrimary\" /&gt; 运行之后 效果还是一样,只不过没字了,因为不是TextView,好了NavigationView有两个属性 app:menu app:headerLayout 具体是做什么的,写完你就知道了 首先我们建立一个menu_nav.xml 肯定在menu文件夹中 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/menu_nav_1\" android:icon=\"@drawable/ic_menu_home\" android:title=\"我是1\" /&gt; &lt;item android:id=\"@+id/menu_nav_2\" android:icon=\"@drawable/ic_menu_home\" android:title=\"我是2\" /&gt; &lt;/group&gt;&lt;/menu&gt; group android:checkableBehavior=”single”这个属性是为了限制单选 我们再建立一个nav_header.xml 在layout文件夹中 &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"180dp\" android:orientation=\"vertical\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/icon_header\" /&gt;&lt;/LinearLayout&gt; 也是很简单的一个布局 为NavigationView设置属性了 &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:id=\"@+id/design_navigation_view\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"@color/colorPrimary\" app:headerLayout=\"@layout/nav_header\" app:menu=\"@menu/menu_nav\" /&gt; 这里是app命名空间,所以需要 xmlns:app=”http://schemas.android.com/apk/res-auto“ 当然 直接alt+enter也会自动添加 运行 这里写图片描述 为NavigationView菜单项设置点击事件 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... if (actionBar != null) &#123; // 使ActionBar左侧的按钮默认可见 是一个← actionBar.setDisplayHomeAsUpEnabled(true); // 修改图标 actionBar.setHomeAsUpIndicator(R.drawable.ic_menu_home); &#125; mNavigationView = (NavigationView) findViewById(R.id.design_navigation_view); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_nav_1: case R.id.menu_nav_2: mDrawerLayout.closeDrawers(); return true; &#125; return false; &#125; &#125;);&#125; 好了我们继续来,悬浮式按钮 FloatingActionButton- 知乎右下角的那个圆型按钮就是了 实现 xml中我们写在ToolBar下方 &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_menu_home\" /&gt;&lt;/FrameLayout&gt; 都是老属性,大家一看效果便能明白: 这里写图片描述 基本事件 它也有基本的OnOlick事件,使用方式和普通View相同,不做过多说明 Snackbar- Snackbar不是Toast的替代品,Snackbar只是能够和用户交互而已,但是会自动消失,介于Dialog和Toast之间的组件,使用方式也是介于两者之间; 我们就在FloatingActionButton的事件中显示Snackbar mFloatingActionButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v, \"然而我弹出来了\", Snackbar.LENGTH_SHORT).setAction(\"点我\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v, \"然而你点我也没用\", Snackbar.LENGTH_SHORT).show(); &#125; &#125;).show(); &#125;&#125;); 运行 这里写图片描述](http://img.blog.csdn.net/20170426100607614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUmVkV29sZkNoYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述 咳咳,这里Snackbar把下面的FAB挡住了,我们需要解决这个问题,谷歌为我们创造了这个问题,肯定也有相应的解决办法- -&gt;CoordinatorLayout CoordinatorLayout-CoordinatorLayout是一个加强版的FrameLayout,可以监听所有子控件的各种事件,然后自动帮我们做出最为合理的相应; 我们把FrameLayout替换为CoordinatorLayout &lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_gravity=\"\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_menu_home\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 运行 这里写图片描述 需要注意的是,只有Snackbar传入的第一个参数View是CoordinatorLayout的子组件时,此效果才会生效,因为我们传入的是v,而v是我们的FAB,所以会生效; CardView- 需要依赖 compile ‘com.android.support:cardview-v7:25.3.1’ 卡片式布局 ,他可以让页面中的元素看起来就像在卡片中一样,并且能够拥有圆角和投影. 咱们把这个卡片里面装上美女放到RecyclerView中去,放松一下… 美女图片需要加载咱们用Glide compile ‘com.github.bumptech.glide:glide:3.7.0’ 首先写一个item布局,顺带着看看CardView的用法 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:elevation=\"5dp\" android:orientation=\"vertical\" app:cardCornerRadius=\"4dp\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:gravity=\"center_horizontal\" android:textSize=\"16sp\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; app:cardCornerRadius=”4dp” 表示圆角的大小android:elevation=”5dp”表示高度Z轴数值越大,高度越高,投影范围越大,投影越浅,反之亦然; CardView本质是一个FrameLayout没啥好的定位方式,咱们就嵌套一个LinearLayout; 之后我们写RecyclerView部分代码,主界面加入RecyclerView ...&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt; // 此处有FAB 影响妹子美观,删除... 写好适配器以及在Activity中设置好Manager以及初始化好数据 ###高能预警:!!!!!!下面会有一长串代码,不想复制的童鞋可以直接跳过### 首先妹子实体 public class MeiZi implements Serializable &#123; private String meiZiName; private int meiZiId; public MeiZi(String meiZiName, int meiZiId) &#123; this.meiZiName = meiZiName; this.meiZiId = meiZiId; &#125; public String getMeiZiName() &#123; return meiZiName; &#125; public void setMeiZiName(String meiZiName) &#123; this.meiZiName = meiZiName; &#125; public int getMeiZiId() &#123; return meiZiId; &#125; public void setMeiZiId(int meiZiId) &#123; this.meiZiId = meiZiId; &#125;&#125; 适配器 public class MeiZiAdapter extends RecyclerView.Adapter&lt;MeiZiAdapter.MeiZiViewHolder&gt; implements View.OnClickListener &#123; private List&lt;MeiZi&gt; meiZiList; private Context mContext; private OnItemClickListener listener; public MeiZiAdapter(List&lt;MeiZi&gt; meiZiList, Context mContext) &#123; this.meiZiList = meiZiList; this.mContext = mContext; &#125; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.listener = listener; &#125; @Override public MeiZiViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_meizi_list, parent, false); view.setOnClickListener(this); return new MeiZiViewHolder(view); &#125; @Override public void onBindViewHolder(MeiZiViewHolder holder, int position) &#123; MeiZi meiZi = meiZiList.get(position); Glide.with(mContext).load(meiZi.getMeiZiId()).into(holder.imageView); holder.textView.setText(meiZi.getMeiZiName()); &#125; @Override public int getItemCount() &#123; return meiZiList.size(); &#125; @Override public void onClick(View v) &#123; if (listener == null) return; listener.OnItemClick(v); &#125; static class MeiZiViewHolder extends RecyclerView.ViewHolder &#123; ImageView imageView; TextView textView; public MeiZiViewHolder(View itemView) &#123; super(itemView); imageView = (ImageView) itemView.findViewById(R.id.image); textView = (TextView) itemView.findViewById(R.id.text); &#125; &#125; public interface OnItemClickListener &#123; void OnItemClick(View v); &#125;&#125; Activity中部分代码 ...initMeiZi(); mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view); mManager = new GridLayoutManager(this, 2); mAdapter = new MeiZiAdapter(meiZiList, this); mRecyclerView.setLayoutManager(mManager); mAdapter.setOnItemClickListener(new MeiZiAdapter.OnItemClickListener() &#123; @Override public void OnItemClick(View v) &#123; Snackbar.make(v, \"点击了第\" + mRecyclerView.getChildAdapterPosition(v) + \"个\" , Snackbar.LENGTH_SHORT).show(); &#125; &#125;); mRecyclerView.setAdapter(mAdapter); &#125; private void initMeiZi() &#123; meiZiList.clear(); for (int i = 0; i &lt; 30; i++) &#123; Random random = new Random(); int index = random.nextInt(fruits.length); meiZiList.add(fruits[index]); &#125; &#125; 运行 这里写图片描述 妹子们还是挺好看的.不过咱们可爱的妹子们把咱们的ToolBar遮挡了…无奈,因为CoordinatorLayout本身是一个FrameLayout,怎么解决?用偏移量么?…不要,MD给我们提供了更好的解决办法 AppBarLayout- AppBarLayout是一个垂直的LinearLayout,用它来包裹一下ToolBar再设置一下属性即可 &lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; app:layout_behavior=”@string/appbar_scrolling_view_behavior”这个,咱们Ctrl点进去看看 android.support.design.widget.AppBarLayout$ScrollingViewBehavior 这么着写,Recycler就会在ToolBar的下方了 这里写图片描述 不过这还不是AppbarLayout真正炫酷的地方.它给他的子控件提供一个属性,可以让它随着列表的操作做出相应的操作 &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways|snap\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; app:layout_scrollFlags=”scroll|enterAlways|snap”&gt; 说明一下 scroll –&gt;当RecyclerView向上滚动时,Toolbar会跟着向上动 enterAlways –&gt;当RecyclerView向下滑动时.ToolBar会跟着向下动并显示 snap –&gt;当RecyclerView还没有完全隐藏或者显示的时候,自动判断ToolBar的显示状态 大家可以自行运行一下 RecyclerView得刷新吧,下拉刷新,MD也给我们提供了一个组件,目前知乎掘金动用到了这个SwipeRefreshLayout SwipeRefreshLayout-没啥解释的,代码才是王道 同样也是用它包裹RecyclerView,当然,RecyclerView的部分属性要移到SwipeRefreshLayout上来; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/swipe_refresh_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 此时运行的话,会这样… 这里写图片描述 这个圈圈消失不掉.因为我们没有对这个SwipeRefreshLayout进行事件响应,下面我们开始写它的事件响应; mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh_layout);// 轮询颜色mSwipeRefreshLayout.setColorSchemeResources(R.color.colorAccent, R.color.colorPrimary, R.color.colorPrimaryDark);mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; initMeiZi(); mAdapter.notifyDataSetChanged(); mSwipeRefreshLayout.setRefreshing(false); &#125;&#125;); 这样就能消失了….简单吧,至于下拉加载更多,博主还没有找到适合MD规范的组件,不过这里提供一种实现方法,仅提供代码 mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); // newState RecyclerView的滑动状态 // 0 滑动停止 // 1 屏幕没停且手在屏幕上 // 2 屏幕没停 惯性滑动 // 当滑动停止并且屏幕最后一个可见的Item的pos+3大于等于ItemCount的时候 下载更多 if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mManager.findLastVisibleItemPosition() + 3 &gt;= mManager.getItemCount()) &#123; initMeiZi(true); mAdapter.notifyDataSetChanged(); &#125; &#125; &#125;);private void initMeiZi(boolean isLoadMore) &#123; if (!isLoadMore) &#123; meiZiList.clear(); &#125; for (int i = 0; i &lt; 25; i++) &#123; Random random = new Random(); int index = random.nextInt(meiZis.length); meiZiList.add(meiZis[index]); &#125;&#125; …还剩一个CollapsingToolbarLayout了吧,那咱们就看看妹子的详情;-) CollapsingToolbarLayout- 配合ToolBar和AppBarLayout实现类似QQ空间的样式 ###高能预警:!!!!!!下面也会有一长串代码,不想复制的童鞋可以直接跳过###具体是详情Act以及跳转的部分代码还有xml public class MeiZiDetailAct extends AppCompatActivity &#123; private Toolbar toolbar; private ImageView imageView; private TextView textView; private MeiZi meiZi; public static void actionStart(Context context, MeiZi fruit) &#123; Intent intent = new Intent(context, MeiZiDetailAct.class); intent.putExtra(\"MEI_ZI\", fruit); context.startActivity(intent); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_meizi_detail); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); &#125; imageView = (ImageView) findViewById(R.id.image); textView = (TextView) findViewById(R.id.text); meiZi = (MeiZi) getIntent().getSerializableExtra(\"MEI_ZI\"); if (meiZi == null) &#123; return; &#125; Glide.with(this).load(meiZi.getMeiZiId()).into(imageView); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 300; i++) &#123; stringBuilder.append(meiZi.getMeiZiName() + \"_ _\" + i + \"_ _\"); &#125; textView.setText(stringBuilder); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: finish(); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 跳转部分 mAdapter.setOnItemClickListener(new MeiZiAdapter.OnItemClickListener() &#123; @Override public void OnItemClick(View v) &#123; MeiZiDetailAct.actionStart(MeiZiListAct.this, meiZiList.get(mRecyclerView.getChildAdapterPosition(v))); &#125;&#125;); &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"250dp\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" app:contentScrim=\"@color/colorPrimary\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scaleType=\"centerCrop\" app:layout_collapseMode=\"parallax\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;android.support.v7.widget.CardView android:id=\"@+id/card_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"15dp\" android:layout_marginLeft=\"15dp\" android:layout_marginRight=\"15dp\" android:layout_marginTop=\"35dp\" app:cardCornerRadius=\"4dp\"&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" /&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_menu_home\" app:layout_anchor=\"@id/app_bar_layout\" app:layout_anchorGravity=\"bottom|end\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这个xml有点长,我简单说一下.CollapsingToolbarLayout app:contentScrim=”@color/colorPrimary” 区域折叠以及折叠后 显示的颜色,CollapsingToolbarLayout折叠之后 就是一个ToolBar app:layout_scrollFlags=”scroll|exitUntilCollapsed”之前见过,exitUntilCollapsed说的是当折叠完成 就停下 不再移出屏幕 Image app:layout_collapseMode=”parallax” 指定它的折叠模式,只有CollapsingToolbarLayout子控件才有的属性, parallax意思是折叠过程中产生错位偏移 app:layout_collapseMode=”pin” 折叠过程中 形状不变 最下面有一个NestedScrollView,可以响应滚动事件,因为只有滚动才能折叠,类似ScrollView但是ScrollView不支持响应滚动; FloatingActionButton app:layout_anchor=”@id/app_bar_layout” 为FAB指定锚点,使其以锚点为基准显示 app:layout_anchorGravity=”bottom|end” 以锚点为基准显示的位置 然后我们运行图录制的不咋地 这里写图片描述 资源都在源码中,可能和本文格式上有点出入,但是代码大致相同; https://github.com/RedWolfChao/MaterialDesignDemo","categories":[],"tags":[{"name":"Material_Design","slug":"Material-Design","permalink":"http://joryhe.coding.me/tags/Material-Design/"}]}]}