{"meta":{"title":"RedWolfChao Blog","subtitle":"沉默是金","description":"学海无涯,回头是岸,阿弥陀佛","author":"RedWolfChao","url":"http://joryhe.coding.me"},"pages":[{"title":"categories","date":"2017-04-24T01:42:11.000Z","updated":"2017-04-24T01:43:05.442Z","comments":true,"path":"categories/index.html","permalink":"http://joryhe.coding.me/categories/index.html","excerpt":"","text":""},{"title":"RedWolfChao Blog","date":"2017-04-24T01:41:06.000Z","updated":"2017-04-26T03:00:35.327Z","comments":true,"path":"tags/index.html","permalink":"http://joryhe.coding.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Material_Design_提供组件","slug":"Material-Design-提供组件","date":"2017-04-26T02:44:41.000Z","updated":"2017-04-26T02:45:26.834Z","comments":true,"path":"post/Material-Design-提供组件.html","link":"","permalink":"http://joryhe.coding.me/post/Material-Design-提供组件.html","excerpt":"","text":"反编译看的实在有点头疼,于是就仔细研究了一下前一段时间的一篇文章Material Design规范,发现这个东西2014年就出来了,为什么我今年才发现呢..无奈.于是乎,读书查资料,撸出一个Demo来; Demo主要知识点&lt;解释纯属个人见解&gt; Toolbar- -&gt;Material Design中推荐用来替代ActionBar的组件 DrawerLayout- -&gt;侧滑菜单的父组件 NavigationView- -&gt;侧滑菜单推荐和DrawerLayout一起组合的使用的菜单组件 FloatingActionButton- -&gt;悬浮按钮 CoordinatorLayout- -&gt;加强版的FrameLayout,拥有部分新特性 Snackbar- -&gt;可交互的Toast(不是替代品) CardView- -&gt;卡片式布局 AppBarLayout-&gt;Toolbar的父组件,封装部分事件 SwipeRefreshLayout- -&gt;下拉刷新组件 CollapsingToolbarLayout- -&gt;只能作为AppBarLayout的直接子布局,用于实现更多效果 RecyclerView- -&gt;ListView的代替品 // 话不多说 1.ToolBar- Toolbar强大之处在于,他不仅继承了ActionBar的所有功能,而且灵活性很高,可以配合其他控件完成一些Material Design的效果 下面我们就来学习一下(首先你需要有一个项目): 修改styles文件中的style部分内容.目的是让ActionBar隐藏,可由多种实现方式,这里提供一种. &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; xml文件中 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt;&lt;/LinearLayout&gt; 高度为?attr/actionBarSize,也可以自己指定,不过MD规范推荐用这个,同样background也是这个道理 运行 这里写图片描述 ..好难看 替换ActionBarActivity中加入代码 protected void onCreate(Bundle savedInstanceState) &#123; ... Toolbar toolBar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolBar); ... &#125; 运行 这里写图片描述 出现我们的Title了,这个是怎么来的,是我们在Manifest中为application设置的label属性的值.和ActionBar是一样的,现在我们的ToolBar才相当于我们的ActionBar,我们也可以修改这个标题,只需要在Manifest中为当前activity添加一个label属性即可 ToolBar还有好多用法,自己太单调,结合后面的组件一起来 DrawerLayout-好多应用都有这种效果,比如QQ,XX,XXX好多软件用MD中推荐了一种做法 需要修改xml根布局为DrawerLayout并加入一个FrameLayout和一个TextView如下: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:id=\"@+id/drawer_layout\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_gravity=\"\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;/FrameLayout&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:text=\"然而我就是侧拉菜单\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 运行 这里写图片描述 android:layout_gravity=”start”用来设置滑动菜单在左边还是右边 然而还是有点儿问题,因为用户可能根本不知道有这个菜单,因为只有从屏幕左侧向右滑动才可以,所以我们要如此这般 Activity中 @Override protected void onCreate(Bundle savedInstanceState) &#123; ... setSupportActionBar(toolBar); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; // 使ActionBar左侧的按钮默认可见 是一个← actionBar.setDisplayHomeAsUpEnabled(true); // 修改图标 actionBar.setHomeAsUpIndicator(R.drawable.ic_menu_home); &#125; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); break; &#125; return true; &#125; // 然而功能是实现了,但是还是很丑,不过可以的,前面已经说了,有个和DrawerLayout组合用的组件,组合起来用就不丑啦. NavigationView- 使用方法很简单,将原本TextView的位置用NavigationView替换了就是了-&gt;需要加依赖&lt;- compile ‘com.android.support:design:25.3.1’ &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"@color/colorPrimary\" /&gt; 运行之后 效果还是一样,只不过没字了,因为不是TextView,好了NavigationView有两个属性 app:menu app:headerLayout 具体是做什么的,写完你就知道了 首先我们建立一个menu_nav.xml 肯定在menu文件夹中 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/menu_nav_1\" android:icon=\"@drawable/ic_menu_home\" android:title=\"我是1\" /&gt; &lt;item android:id=\"@+id/menu_nav_2\" android:icon=\"@drawable/ic_menu_home\" android:title=\"我是2\" /&gt; &lt;/group&gt;&lt;/menu&gt; group android:checkableBehavior=”single”这个属性是为了限制单选 我们再建立一个nav_header.xml 在layout文件夹中 &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"180dp\" android:orientation=\"vertical\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/icon_header\" /&gt;&lt;/LinearLayout&gt; 也是很简单的一个布局 为NavigationView设置属性了 &lt;android.support.design.widget.NavigationView android:layout_width=\"match_parent\" android:id=\"@+id/design_navigation_view\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"@color/colorPrimary\" app:headerLayout=\"@layout/nav_header\" app:menu=\"@menu/menu_nav\" /&gt; 这里是app命名空间,所以需要 xmlns:app=”http://schemas.android.com/apk/res-auto“ 当然 直接alt+enter也会自动添加 运行 这里写图片描述 为NavigationView菜单项设置点击事件 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... if (actionBar != null) &#123; // 使ActionBar左侧的按钮默认可见 是一个← actionBar.setDisplayHomeAsUpEnabled(true); // 修改图标 actionBar.setHomeAsUpIndicator(R.drawable.ic_menu_home); &#125; mNavigationView = (NavigationView) findViewById(R.id.design_navigation_view); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_nav_1: case R.id.menu_nav_2: mDrawerLayout.closeDrawers(); return true; &#125; return false; &#125; &#125;);&#125; 好了我们继续来,悬浮式按钮 FloatingActionButton- 知乎右下角的那个圆型按钮就是了 实现 xml中我们写在ToolBar下方 &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_menu_home\" /&gt;&lt;/FrameLayout&gt; 都是老属性,大家一看效果便能明白: 这里写图片描述 基本事件 它也有基本的OnOlick事件,使用方式和普通View相同,不做过多说明 Snackbar- Snackbar不是Toast的替代品,Snackbar只是能够和用户交互而已,但是会自动消失,介于Dialog和Toast之间的组件,使用方式也是介于两者之间; 我们就在FloatingActionButton的事件中显示Snackbar mFloatingActionButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v, \"然而我弹出来了\", Snackbar.LENGTH_SHORT).setAction(\"点我\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v, \"然而你点我也没用\", Snackbar.LENGTH_SHORT).show(); &#125; &#125;).show(); &#125;&#125;); 运行 这里写图片描述](http://img.blog.csdn.net/20170426100607614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUmVkV29sZkNoYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述 咳咳,这里Snackbar把下面的FAB挡住了,我们需要解决这个问题,谷歌为我们创造了这个问题,肯定也有相应的解决办法- -&gt;CoordinatorLayout CoordinatorLayout-CoordinatorLayout是一个加强版的FrameLayout,可以监听所有子控件的各种事件,然后自动帮我们做出最为合理的相应; 我们把FrameLayout替换为CoordinatorLayout &lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:layout_gravity=\"\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_menu_home\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 运行 这里写图片描述 需要注意的是,只有Snackbar传入的第一个参数View是CoordinatorLayout的子组件时,此效果才会生效,因为我们传入的是v,而v是我们的FAB,所以会生效; CardView- 需要依赖 compile ‘com.android.support:cardview-v7:25.3.1’ 卡片式布局 ,他可以让页面中的元素看起来就像在卡片中一样,并且能够拥有圆角和投影. 咱们把这个卡片里面装上美女放到RecyclerView中去,放松一下… 美女图片需要加载咱们用Glide compile ‘com.github.bumptech.glide:glide:3.7.0’ 首先写一个item布局,顺带着看看CardView的用法 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:elevation=\"5dp\" android:orientation=\"vertical\" app:cardCornerRadius=\"4dp\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:gravity=\"center_horizontal\" android:textSize=\"16sp\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; app:cardCornerRadius=”4dp” 表示圆角的大小android:elevation=”5dp”表示高度Z轴数值越大,高度越高,投影范围越大,投影越浅,反之亦然; CardView本质是一个FrameLayout没啥好的定位方式,咱们就嵌套一个LinearLayout; 之后我们写RecyclerView部分代码,主界面加入RecyclerView ...&lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt; // 此处有FAB 影响妹子美观,删除... 写好适配器以及在Activity中设置好Manager以及初始化好数据 ###高能预警:!!!!!!下面会有一长串代码,不想复制的童鞋可以直接跳过### 首先妹子实体 public class MeiZi implements Serializable &#123; private String meiZiName; private int meiZiId; public MeiZi(String meiZiName, int meiZiId) &#123; this.meiZiName = meiZiName; this.meiZiId = meiZiId; &#125; public String getMeiZiName() &#123; return meiZiName; &#125; public void setMeiZiName(String meiZiName) &#123; this.meiZiName = meiZiName; &#125; public int getMeiZiId() &#123; return meiZiId; &#125; public void setMeiZiId(int meiZiId) &#123; this.meiZiId = meiZiId; &#125;&#125; 适配器 public class MeiZiAdapter extends RecyclerView.Adapter&lt;MeiZiAdapter.MeiZiViewHolder&gt; implements View.OnClickListener &#123; private List&lt;MeiZi&gt; meiZiList; private Context mContext; private OnItemClickListener listener; public MeiZiAdapter(List&lt;MeiZi&gt; meiZiList, Context mContext) &#123; this.meiZiList = meiZiList; this.mContext = mContext; &#125; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.listener = listener; &#125; @Override public MeiZiViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_meizi_list, parent, false); view.setOnClickListener(this); return new MeiZiViewHolder(view); &#125; @Override public void onBindViewHolder(MeiZiViewHolder holder, int position) &#123; MeiZi meiZi = meiZiList.get(position); Glide.with(mContext).load(meiZi.getMeiZiId()).into(holder.imageView); holder.textView.setText(meiZi.getMeiZiName()); &#125; @Override public int getItemCount() &#123; return meiZiList.size(); &#125; @Override public void onClick(View v) &#123; if (listener == null) return; listener.OnItemClick(v); &#125; static class MeiZiViewHolder extends RecyclerView.ViewHolder &#123; ImageView imageView; TextView textView; public MeiZiViewHolder(View itemView) &#123; super(itemView); imageView = (ImageView) itemView.findViewById(R.id.image); textView = (TextView) itemView.findViewById(R.id.text); &#125; &#125; public interface OnItemClickListener &#123; void OnItemClick(View v); &#125;&#125; Activity中部分代码 ...initMeiZi(); mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view); mManager = new GridLayoutManager(this, 2); mAdapter = new MeiZiAdapter(meiZiList, this); mRecyclerView.setLayoutManager(mManager); mAdapter.setOnItemClickListener(new MeiZiAdapter.OnItemClickListener() &#123; @Override public void OnItemClick(View v) &#123; Snackbar.make(v, \"点击了第\" + mRecyclerView.getChildAdapterPosition(v) + \"个\" , Snackbar.LENGTH_SHORT).show(); &#125; &#125;); mRecyclerView.setAdapter(mAdapter); &#125; private void initMeiZi() &#123; meiZiList.clear(); for (int i = 0; i &lt; 30; i++) &#123; Random random = new Random(); int index = random.nextInt(fruits.length); meiZiList.add(fruits[index]); &#125; &#125; 运行 这里写图片描述 妹子们还是挺好看的.不过咱们可爱的妹子们把咱们的ToolBar遮挡了…无奈,因为CoordinatorLayout本身是一个FrameLayout,怎么解决?用偏移量么?…不要,MD给我们提供了更好的解决办法 AppBarLayout- AppBarLayout是一个垂直的LinearLayout,用它来包裹一下ToolBar再设置一下属性即可 &lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; app:layout_behavior=”@string/appbar_scrolling_view_behavior”这个,咱们Ctrl点进去看看 android.support.design.widget.AppBarLayout$ScrollingViewBehavior 这么着写,Recycler就会在ToolBar的下方了 这里写图片描述 不过这还不是AppbarLayout真正炫酷的地方.它给他的子控件提供一个属性,可以让它随着列表的操作做出相应的操作 &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways|snap\"&gt;&lt;/android.support.v7.widget.Toolbar&gt; app:layout_scrollFlags=”scroll|enterAlways|snap”&gt; 说明一下 scroll –&gt;当RecyclerView向上滚动时,Toolbar会跟着向上动 enterAlways –&gt;当RecyclerView向下滑动时.ToolBar会跟着向下动并显示 snap –&gt;当RecyclerView还没有完全隐藏或者显示的时候,自动判断ToolBar的显示状态 大家可以自行运行一下 RecyclerView得刷新吧,下拉刷新,MD也给我们提供了一个组件,目前知乎掘金动用到了这个SwipeRefreshLayout SwipeRefreshLayout-没啥解释的,代码才是王道 同样也是用它包裹RecyclerView,当然,RecyclerView的部分属性要移到SwipeRefreshLayout上来; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/swipe_refresh_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 此时运行的话,会这样… 这里写图片描述 这个圈圈消失不掉.因为我们没有对这个SwipeRefreshLayout进行事件响应,下面我们开始写它的事件响应; mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh_layout);// 轮询颜色mSwipeRefreshLayout.setColorSchemeResources(R.color.colorAccent, R.color.colorPrimary, R.color.colorPrimaryDark);mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; initMeiZi(); mAdapter.notifyDataSetChanged(); mSwipeRefreshLayout.setRefreshing(false); &#125;&#125;); 这样就能消失了….简单吧,至于下拉加载更多,博主还没有找到适合MD规范的组件,不过这里提供一种实现方法,仅提供代码 mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); // newState RecyclerView的滑动状态 // 0 滑动停止 // 1 屏幕没停且手在屏幕上 // 2 屏幕没停 惯性滑动 // 当滑动停止并且屏幕最后一个可见的Item的pos+3大于等于ItemCount的时候 下载更多 if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mManager.findLastVisibleItemPosition() + 3 &gt;= mManager.getItemCount()) &#123; initMeiZi(true); mAdapter.notifyDataSetChanged(); &#125; &#125; &#125;);private void initMeiZi(boolean isLoadMore) &#123; if (!isLoadMore) &#123; meiZiList.clear(); &#125; for (int i = 0; i &lt; 25; i++) &#123; Random random = new Random(); int index = random.nextInt(meiZis.length); meiZiList.add(meiZis[index]); &#125;&#125; …还剩一个CollapsingToolbarLayout了吧,那咱们就看看妹子的详情;-) CollapsingToolbarLayout- 配合ToolBar和AppBarLayout实现类似QQ空间的样式 ###高能预警:!!!!!!下面也会有一长串代码,不想复制的童鞋可以直接跳过###具体是详情Act以及跳转的部分代码还有xml public class MeiZiDetailAct extends AppCompatActivity &#123; private Toolbar toolbar; private ImageView imageView; private TextView textView; private MeiZi meiZi; public static void actionStart(Context context, MeiZi fruit) &#123; Intent intent = new Intent(context, MeiZiDetailAct.class); intent.putExtra(\"MEI_ZI\", fruit); context.startActivity(intent); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_meizi_detail); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); &#125; imageView = (ImageView) findViewById(R.id.image); textView = (TextView) findViewById(R.id.text); meiZi = (MeiZi) getIntent().getSerializableExtra(\"MEI_ZI\"); if (meiZi == null) &#123; return; &#125; Glide.with(this).load(meiZi.getMeiZiId()).into(imageView); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 300; i++) &#123; stringBuilder.append(meiZi.getMeiZiName() + \"_ _\" + i + \"_ _\"); &#125; textView.setText(stringBuilder); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: finish(); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 跳转部分 mAdapter.setOnItemClickListener(new MeiZiAdapter.OnItemClickListener() &#123; @Override public void OnItemClick(View v) &#123; MeiZiDetailAct.actionStart(MeiZiListAct.this, meiZiList.get(mRecyclerView.getChildAdapterPosition(v))); &#125;&#125;); &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"250dp\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" app:contentScrim=\"@color/colorPrimary\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scaleType=\"centerCrop\" app:layout_collapseMode=\"parallax\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;android.support.v7.widget.CardView android:id=\"@+id/card_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"15dp\" android:layout_marginLeft=\"15dp\" android:layout_marginRight=\"15dp\" android:layout_marginTop=\"35dp\" app:cardCornerRadius=\"4dp\"&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" /&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_menu_home\" app:layout_anchor=\"@id/app_bar_layout\" app:layout_anchorGravity=\"bottom|end\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这个xml有点长,我简单说一下.CollapsingToolbarLayout app:contentScrim=”@color/colorPrimary” 区域折叠以及折叠后 显示的颜色,CollapsingToolbarLayout折叠之后 就是一个ToolBar app:layout_scrollFlags=”scroll|exitUntilCollapsed”之前见过,exitUntilCollapsed说的是当折叠完成 就停下 不再移出屏幕 Image app:layout_collapseMode=”parallax” 指定它的折叠模式,只有CollapsingToolbarLayout子控件才有的属性, parallax意思是折叠过程中产生错位偏移 app:layout_collapseMode=”pin” 折叠过程中 形状不变 最下面有一个NestedScrollView,可以响应滚动事件,因为只有滚动才能折叠,类似ScrollView但是ScrollView不支持响应滚动; FloatingActionButton app:layout_anchor=”@id/app_bar_layout” 为FAB指定锚点,使其以锚点为基准显示 app:layout_anchorGravity=”bottom|end” 以锚点为基准显示的位置 然后我们运行图录制的不咋地 这里写图片描述 资源都在源码中,可能和本文格式上有点出入,但是代码大致相同; https://github.com/RedWolfChao/MaterialDesignDemo","categories":[],"tags":[{"name":"Material_Design","slug":"Material-Design","permalink":"http://joryhe.coding.me/tags/Material-Design/"}]},{"title":"我是测试文件","slug":"测试2","date":"2017-04-24T03:05:40.000Z","updated":"2017-04-26T03:02:35.010Z","comments":true,"path":"post/测试2.html","link":"","permalink":"http://joryhe.coding.me/post/测试2.html","excerpt":"","text":"###然而我是测试的Mark### /** * 无奈 */private void method() &#123; // 无奈我是测试文件&#125;","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://joryhe.coding.me/tags/测试/"}]}]}